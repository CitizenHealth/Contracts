pragma solidity ^0.4.17;

import './SafeMath.sol';

contract metadata{
    function getAddress (uint256 addressId) public view returns (address);
    function addAddress (uint256 addressId, address addressContract) public;
}

/**
 * @title ERC20 interface
 */
contract ERC20 {
  uint256 public totalSupply;
  function balanceOf(address _owner) public view returns (uint256 value);
  function transfer(address _to, uint256 _value) public returns (bool _success);
  function allowance(address owner, address spender) public view returns (uint256 _value);
  function transferFrom(address from, address to, uint256 value) public returns (bool _success);
  function approve(address spender, uint256 value) public returns (bool _success);
  event Approval(address indexed owner, address indexed spender, uint256 value);
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
}

/**
 * @title ERC223 recieving interface
 */
contract ERC223ReceivingContract {
    function tokenFallback(address _from, uint256 _value, bytes _data) public{
    }
}

/**
 * @title ERC223 interface
 */
contract ERC223 is ERC20{
   function transfer(address _to, uint256 _value, bytes _data) public returns (bool _success);
   event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);
}

/**
 * @title tokenMedit to implement token
 */
contract tokenMedit is ERC223, ERC223ReceivingContract {

    using SafeMath for uint256;
    //The name of the  token
    string public name;
    //The token symbol
    string public symbol;
    //The account deploying the contract
    address public owner;
    //To denote the locking on transfer of tokens among token holders
    bool public locked;
    //The precision used in the calculations in contract
    uint8 public decimals;

    //Mapping to relate number of  token to the account
    mapping(address => uint256 ) balances;
    //Mapping to relate owner and spender to the tokens allowed to transfer from owner
    mapping(address => mapping(address => uint256)) allowed;
    //this contract ID
    uint256 constant private IDtokenMedit = 1;
    //presale contract Id
    uint256 constant private IDpresale = 2;
    //crowdsale contract ID
    uint256 constant private IDcrowdsale = 3;
    //variable of type metadata to store metadata contract object
    metadata private metadataContract;

    //Important addresses

    address private metadataContrAddr;
    address private crowdsaleAddress;
    address private communityAddress;
    address private teamAddress;
    address private foundationAddress;
    address private charityAddress;
    address private partnershipsAddress;
    address private advisorsAddress;

    /**
    * @dev Constructor of tokenMedit
    */
    function tokenMedit(
      address _metadataContrAddr,
      address _crowdsaleAddress,
      address _communityAddress,
      address _teamAddress,
      address _foundationAddress,
      address _charityAddress,
      address _partnershipsAddress,
      address _advisorsAddress
      ) public {
        assert( _metadataContrAddr != address(0) &&
          _crowdsaleAddress != address(0) &&
          _communityAddress != address(0) &&
          _teamAddress != address(0) &&
          _foundationAddress != address(0) &&
          _charityAddress != address(0) &&
          _partnershipsAddress !=address(0) &&
          _advisorsAddress!= address(0) );
        
        metadataContrAddr = _metadataContrAddr;
        crowdsaleAddress = _crowdsaleAddress;
        communityAddress = _communityAddress;
        teamAddress = _teamAddress;
        foundationAddress = _foundationAddress;
        charityAddress = _charityAddress;
        partnershipsAddress = _partnershipsAddress;
        advisorsAddress = _advisorsAddress;

        /* Public variables of the token */
        //The name of the  token
        name = "MEDIT";
        //The token symbol
        symbol = "MEDIT";
        //Total number of tokens that can be generated by this contract
        totalSupply = 10000000000e18; //10 billion
        //The account used to deploy the contract will become the owner of contract
        owner = msg.sender;
        //Transfer of tokens is locked (not allowed) when contract is deployed
        locked = true;
        //Number of zeroes to be treated as decimals
        decimals = 18;
        //Initially, all the tokens are with owner's account
        balances[owner] = totalSupply;
        //passing address of meta data contract to metadat type address variable
        metadataContract = metadata(metadataContrAddr);
        // one who has deployed metadata, is allowed to deploy tokenMedit
        // Id of owner of metadata is 0
        assert(metadataContract.getAddress(0) == msg.sender);
        //storing address of token medit contract in metadata
        metadataContract.addAddress(IDtokenMedit, this);

        //Initialize balances
        //crowdsaleAddress gets 10% of 10 billion
        balances[crowdsaleAddress] = 1000000000e18;
        //Community Incentives 35%
        balances[communityAddress] = 3500000000e18;
        //Team 10%
        balances[teamAddress] = 1000000000e18;
        //Foundation 25%
        balances[foundationAddress] = 2500000000e18;
        //Charity 10%
        balances[charityAddress] = 1000000000e18;
        //Partnerships 7%
        balances[partnershipsAddress] = 700000000e18;
        //Advisors & Early Contributors 3%
        balances[advisorsAddress] = 300000000e18;
    }

    modifier onlyUnlocked() { 
      require (!locked); 
      _; 
    }
    
    //To enable transfer of tokens
    function unlockTransfer() external {
      address crowdsaleContractAddress = metadataContract.getAddress(IDcrowdsale);
      assert(msg.sender == crowdsaleContractAddress);
      locked = false;
    }

    /**
     * @dev Check if the address being passed belongs to a contract
     *
     * @param _address The address which you want to verify
     * @return A bool specifying if the address is that of contract or not
     */
    function isContract(address _address) private view returns(bool _isContract){
        assert(_address != address(0) );
        uint256 length;
        //inline assembly code to check the length of address
        assembly{
            length := extcodesize(_address)
        }
        if(length > 0){
            return true;
        }
        else{
            return false;
        }
    }

    /**
    * @dev Check balance of given account address
    *
    * @param _owner The address account whose balance you want to know
    * @return balance of the account
    */
    function balanceOf(address _owner) public view returns (uint256 _value){
        return balances[_owner];
    }

    function addTokenBalance(address beneficiary, uint256 amount) public{
        require(amount  > 0 && beneficiary != address(0) );
        //only owner of metadataContract should be able to change tokens
        require( msg.sender == metadataContract.getAddress(IDpresale) ||
        msg.sender == metadataContract.getAddress(IDcrowdsale));
        balances[beneficiary] = balances[beneficiary].Add(amount);
    }

    function reduceTokenBalance(uint256 amount) public{
        require(amount > 0 );
        //only owner of metadataContract should be able to change tokens
        require( msg.sender == metadataContract.getAddress(IDpresale) ||
        msg.sender == metadataContract.getAddress(IDcrowdsale));
        balances[crowdsaleAddress] = balances[crowdsaleAddress].Sub(amount);
    }

    /**
    * @dev Transfer tokens to an address given by sender
    *
    * @param _to The address which you want to transfer to
    * @param _value the amount of tokens to be transferred
    * @return A bool if the transfer was a success or not
    */
    function transfer(address _to, uint256 _value) onlyUnlocked public returns(bool _success) {
        require( _to != address(0) && _value > 0);
        bytes memory _empty;
        balances[msg.sender] = balances[msg.sender].Sub(_value);
        balances[_to] = balances[_to].Add(_value);

        if(isContract(_to)){
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(msg.sender, _value, _empty);
        }

        Transfer(msg.sender, _to, _value, _empty);

        return true;
    }

    /**
    * @dev Transfer tokens to an address given by sender. To make ERC223 compliant
    *
    * @param _to The address which you want to transfer to
    * @param _value the amount of tokens to be transferred
    * @param _data additional information of account from where to transfer from
    * @return A bool if the transfer was a success
    */
    function transfer(address _to, uint256 _value, bytes _data) onlyUnlocked public returns(bool _success) {
        require( _value > 0 && _to != address(0));
        balances[msg.sender] = balances[msg.sender].Sub(_value);
        balances[_to] = balances[_to].Add(_value);

        if(isContract(_to)){
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }

        Transfer(msg.sender, _to, _value, _data);

        return true;

    }

    /**
    * @dev Transfer tokens from one address to another, for ERC20.
    *
    * @param _from The address which you want to send tokens from
    * @param _to The address which you want to transfer to
    * @param _value the amount of tokens to be transferred
    * @return A bool if the transfer was a success or not
    */
    function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns (bool){
        bytes memory _empty;
        require((_value > 0)
           && (_to != address(0))
           && (_from != address(0))
           && (allowed[_from][msg.sender] >= _value ));
            balances[_from] = balances[_from].Sub(_value);
            balances[_to] = balances[_to].Add(_value);
            allowed[_from][msg.sender] = allowed[_from][msg.sender].Sub(_value);
            if(isContract(_to)){
                ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
                receiver.tokenFallback(msg.sender, _value, _empty);
            }
            Transfer(_from, _to, _value, _empty);
            return true;
    }

    /**
    * @dev Function to check the amount of tokens that an owner has allowed a spender to recieve from owner.
    *
    * @param _owner address The address which owns the funds.
    * @param _spender address The address which will spend the funds.
    * @return A uint256 specifying the amount of tokens still available for the spender to spend.
    */
    function allowance(address _owner, address _spender) public view returns (uint256){
        return allowed[_owner][_spender];
    }

    /**
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    *
    * @param _spender The address which will spend the funds.
    * @param _value The amount of tokens to be spent.
    */
    function approve(address _spender, uint256 _value) public returns (bool){
        require( _value > 0 && (_spender != address(0)) && balances[msg.sender] >=_value);
        //to check for race condition. Allow approval only after spender amount has been set to zero
        assert(allowed[msg.sender][_spender] == 0 || _value == 0);
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

}
